import shutil
from typing import Union
import uuid
from passlib.context import CryptContext
import secrets
import hashlib
import shortuuid
import string, random
import os
from fastapi import HTTPException, UploadFile
from tempfile import NamedTemporaryFile
from b2sdk.v2 import InMemoryAccountInfo, B2Api
from .config import settings

info = InMemoryAccountInfo()
b2_api = B2Api(info)
b2_api.authorize_account("production", settings.backblaze_id, settings.backblaze_key)


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def hash_password(password: str):
    """
    Hash a password using the CryptContext from passlib.context.

    Args:
        password (str): The password to hash.

    Returns:
        str: The hashed password.
    """
    return pwd_context.hash(password)


def verify(plain_password, hashed_password):
    """
    Verify that a plaintext password matches a previously hashed password.

    Args:
        plain_password (str): The plaintext password to compare.
        hashed_password (str): The hashed password to compare against.

    Returns:
        bool: True if the passwords match, False otherwise.
    """
    return pwd_context.verify(plain_password, hashed_password)


def generate_unique_token(email: str) -> str:
    """
    Generate a unique and secure token for a user.

    Args:
        email (str): The email of the user for which to generate the token.

    Returns:
        str: A unique and secure token for the user.
    """
    # Create a base token using a new random number
    base_token = secrets.token_urlsafe()
    # Use the user's email to personalize the token
    personalized_token = f"{base_token}{email}"
    # Create a SHA256 hash of the personalized token
    return hashlib.sha256(personalized_token.encode()).hexdigest()



def generate_reset_code():
    return ''.join(random.choices(string.digits, k=6))


def generate_random_code(length=10):
    characters = string.ascii_letters + string.digits
    return ''.join(secrets.choice(characters) for _ in range(length))


def generate_access_code_uuid4():
    return uuid.uuid4()


def generate_user_id_hash(username):
    return hashlib.md5(username.encode()).hexdigest()

def generate_unique_code_shortuuid():
    return shortuuid.uuid()

# User options
def generate_unique_filename(filename):
    """
    Generate a unique filename by appending a random suffix to the original filename.

    Parameters:
    filename (str): The original filename.

    Returns:
    str: The unique filename.

    The unique filename is generated by appending a random suffix to the original filename.
    The suffix is a combination of lowercase and uppercase letters and digits.
    The length of the suffix is 8 characters by default.
    """
    file_name, file_extension = os.path.splitext(filename)
    unique_suffix = generate_random_code()
    unique_filename = f"{file_name}_{unique_suffix}{file_extension}"
    return unique_filename





async def upload_to_backblaze(file: Union[UploadFile, str], image_backed: str) -> str:
    """
    Uploads a file or a file at a given path to the specified Backblaze B2 bucket.
    """
    try:
        # Determine if the input is a file path or an UploadFile
        if isinstance(file, str):
            # If it's a string, assume it's a file path
            file_path = file
            file_name = os.path.basename(file_path)
        else:
            # It's an UploadFile; create a temporary file to copy to
            with NamedTemporaryFile(delete=False) as temp_file:
                shutil.copyfileobj(file.file, temp_file)
                file_path = temp_file.name
                file_name = file.filename

        # Ensure the filename is unique
        unique_filename = generate_unique_filename(file_name)

        bucket_name = image_backed
        bucket = b2_api.get_bucket_by_name(bucket_name)

        # Upload file to Backblaze B2
        bucket.upload_local_file(
            local_file=file_path,
            file_name=unique_filename
        )

        # Get public URL of the uploaded file
        download_url = b2_api.get_download_url_for_file_name(bucket_name, unique_filename)
        return download_url
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to upload file: {str(e)}")
    finally:
        # Clean up if a temporary file was used
        if isinstance(file, UploadFile) and file and hasattr(file, 'file'):
            file.file.close()
        if isinstance(file, str):
            os.remove(file_path)  # Remove the generated image file after uploading